#!/usr/bin/env python3
"""Generate signal synonym mappings from taxonomy metadata."""
from __future__ import annotations

import json
import sys
from pathlib import Path
from typing import Any


def _load_json(path: Path) -> Any:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def main() -> int:
    repo_root = Path(__file__).resolve().parents[1]
    signals_path = repo_root / "packages" / "specs" / "docs" / "contracts" / "taxonomy" / "signals.json"
    meta_path = repo_root / "packages" / "specs" / "docs" / "contracts" / "taxonomy" / "signals.meta.json"
    output_path = repo_root / "packages" / "ep" / "aigov_ep" / "taxonomy" / "signal_synonyms_gen.py"

    if not signals_path.exists():
        print(f"ERROR: signals.json not found: {signals_path}")
        return 1
    if not meta_path.exists():
        print(f"ERROR: signals.meta.json not found: {meta_path}")
        return 1

    signals_data = _load_json(signals_path)
    meta_data = _load_json(meta_path)

    canonical_ids = signals_data.get("signal_ids", [])
    if not isinstance(canonical_ids, list) or not canonical_ids:
        print("ERROR: signal_ids missing or invalid in signals.json")
        return 1

    canonical_set = set(canonical_ids)
    meta_keys = set(meta_data.keys())

    unknown_keys = meta_keys - canonical_set
    if unknown_keys:
        print(f"ERROR: unknown signal IDs in meta: {sorted(unknown_keys)}")
        return 1

    missing_keys = canonical_set - meta_keys
    if missing_keys:
        print(f"ERROR: missing signal IDs in meta: {sorted(missing_keys)}")
        return 1

    definitions: dict[str, str] = {}
    synonyms_map: dict[str, str] = {}

    for signal_id in canonical_ids:
        meta = meta_data.get(signal_id)
        if not isinstance(meta, dict):
            print(f"ERROR: meta for {signal_id} must be an object")
            return 1
        definition = meta.get("definition")
        if not isinstance(definition, str) or not definition.strip():
            print(f"ERROR: definition missing/invalid for {signal_id}")
            return 1
        definitions[signal_id] = definition.strip()

        synonyms = meta.get("synonyms", [])
        if synonyms is None:
            synonyms = []
        if not isinstance(synonyms, list):
            print(f"ERROR: synonyms must be a list for {signal_id}")
            return 1
        for synonym in synonyms:
            if not isinstance(synonym, str) or not synonym.strip():
                print(f"ERROR: synonym must be a non-empty string for {signal_id}")
                return 1
            cleaned = synonym.strip()
            existing = synonyms_map.get(cleaned)
            if existing is not None:
                print(
                    "ERROR: synonym collision for "
                    f"'{cleaned}' between {existing} and {signal_id}"
                )
                return 1
            synonyms_map[cleaned] = signal_id

    output_lines = [
        "# This file is auto-generated by tools/build_signal_synonyms.py.\n",
        "# Do not edit manually.\n",
        "\n",
        "SIGNAL_DEFINITIONS = {\n",
    ]
    for key in canonical_ids:
        value = definitions[key].replace("\\", "\\\\").replace("\"", "\\\"")
        output_lines.append(f"    \"{key}\": \"{value}\",\n")
    output_lines.append("}\n\n")

    output_lines.append("SIGNAL_SYNONYMS = {\n")
    for synonym in sorted(synonyms_map):
        target = synonyms_map[synonym]
        escaped_syn = synonym.replace("\\", "\\\\").replace("\"", "\\\"")
        output_lines.append(f"    \"{escaped_syn}\": \"{target}\",\n")
    output_lines.append("}\n")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("".join(output_lines), encoding="utf-8")

    print(f"Wrote {output_path}")
    print(f"Definitions: {len(definitions)}")
    print(f"Synonyms: {len(synonyms_map)}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
